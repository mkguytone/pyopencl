<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>13.6. OpenCLフレームワークモデル</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Python OpenCL入門" /><link rel="up" href="ch13.html" title="Chapter 13. OpenCLの概要" /><link rel="prev" href="ch13s05.html" title="13.5. OpenCLの特徴" /><link rel="next" href="ch13s07.html" title="13.7. OpenCLカーネルプログラミング" /><meta xmlns="" name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch13s05.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch13s07.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_openclフレームワークモデル"></a>13.6. OpenCLフレームワークモデル</h2></div></div></div><p>OpenCLによるヘテロジニアスデバイス環境の抽象化を理解して頂くには、OpenCL APIが何をするかを見て頂くと良いかと思います。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
ヘテロジニアス環境のプロットフォームを検出
</li><li class="listitem">
プラットフォーム下のハードウェアコンポーネントを検出
</li><li class="listitem">
コンポーネントの属性を取得
</li><li class="listitem">
コンポーネントで実行される命令セット（kernel）をコンパイル
</li><li class="listitem">
演算に使う入力データをメモリーバッファーに変換
</li><li class="listitem">
選択したプラットフォーム、コンポーネントでkernelを実行
</li><li class="listitem">
kernelの実行結果を取得
</li></ol></div><p>このようにステップバイステップで処理が進むのですが、これらのステップを大きく分類すると、以下の４つのようなモデルにまとめることができます。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
プラットフォームモデル（Platform Model）
</li><li class="listitem">
実行モデル（Execution Model）
</li><li class="listitem">
メモリモデル（Memory Model）
</li><li class="listitem">
プログラミングモデル（Programming Model）
</li></ul></div><p>これらのモデルについては以降の項目で解説していきます。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="platform-model-chapter"></a>13.6.1. プラットフォームモデル</h3></div></div></div><p>Platform Modelはヘテロジニアスなシステム環境を上流層を記述するモデルです。これによりアーキテクチャーの異なるマイクロプロセッサーを検出しアクセスすることを可能とします。</p><p>OpenCLプラットフォームは以下の図に示されるように、マイクロプロセッサーを抽象化したものです。</p><div class="figure"><a id="devicepe"></a><p class="title"><strong>Figure 13.1. 図表：プロセッサー・アーキテクチャー</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/OpenCLDevicePE.png" alt="images/OpenCLDevicePE.png" /></div></div></div><br class="figure-break" /><p>プラットフォームはホスト、デバイス（プロセッサー）、CU、PEから構成されます。CUとPEの定義は以下のようになります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
(CU)Compute Unit: 一つ以上の演算ユニットを持つOpenCLデバイスです。ワークグループは単一演算ユニットで実行されます。Compute Unitは一つ以上の処理要素（processing elements: PE）とローカルメモリーで構成されます。
</li><li class="listitem">
(PE)Processing Element: 仮想スカラプロセッサです。プロセッサーに入っている最小単位（つまりスカラ型）の演算器に論理的にマップした仮想プロセッサです。
</li></ul></div><p>図ではGPU内に４個のCU、各CUに4個のPEで、計16個のPEがあります。CPUには2つのCU、計8個のPEがあります。Intel CPUの例でいえば、CUはコアに相当します。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="execution-model-chapter"></a>13.6.2. 実行モデル（Execution Model）</h3></div></div></div><p>Execution Modelは名前のとおり命令セットの実行を行うためのモデルです。このモデルは異種のアーキテクチャーが混在した環境のもとでの実行処理するためにあります。</p><p>実行モデルは１つのホスト（端末）に対して複数のOpenCLデバイスが存在するという前提を持ち、OpenCLデバイスでの実行プログラムを、ホストプログラムと分離させています。</p><p>ホストプログラムはホスト上で動作するもので、GPU等で動作するプログラムとは区別されます。ホストプログラムで不可欠なオブジェクトには以下のようなものがあります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
コンテキスト
</li><li class="listitem">
コマンドキュー
</li><li class="listitem">
プログラム
</li><li class="listitem">
メモリオブジェクト
</li></ul></div><p>ヘテロジニアスな環境ではマイクロプロセッサが混在しており、ドライバも異なります。OpenCLでは実行モデルにランタイムで、カーネルと呼ばれる関数のソースコードをコンパイル・ビルドする機構を持ちます。カーネルをコンパイル・ビルドをするのはプログラムオブジェクトとなり、そこからカーネルオブジェクトを生成します。生成されたカーネルはデバイスに送られ実行処理されます。</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>カーネルの実装例は「<a class="xref" href="ch13s07.html#kernelFuncChapter" title="13.7.1. カーネル関数">Section 13.7.1, “カーネル関数”</a>」を参照ください。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="kernelExecutionChapter"></a>カーネルの実行</h4></div></div></div><p>ホストプログラムはOpenCLデバイスでの処理実行のためのカーネルを送るコマンドを発行します。</p><p>コマンドを発行時に、ホスト内に指定された整数のインデックス空間を生成します。カーネルのインスタンスはこのインデックス空間の各ポイントを実行します。</p><p>カーネルの各インスタンスをワークアイテムとよび、各インスタンスは整数のインデックス空間の座標で識別できます。この座標はワークアイテムのグローバルIDと呼びます。</p><p>ワークアイテムはスレッドと考えると分かりやすいかもしれません。カーネルコマンドが発行されるとワークアイテムのコレクションを生成します。インデックス空間の整数（又はグローバルID）で識別される各ワークアイテムは、同一のカーネルが指定する命令シーケンスを実行します。つまり同一のカーネルが、並列で処理され、実行中の各カーネルはグローバルIDで識別することが可能となります。</p><p>各ワークアイテムの処理内容は多くの場合に異なります。グローバルIDを入力データ配列要素のインデックスとして使用し、同じ命令シーケンスでも他のワークアイテムが持つグローバルIDが指す配列要素とはインデックスが異なる要素を処理したり、命令シーケンス内の分岐処理などによって、処理結果が各ワークアイテムで異なる形態をとらせることができます。この処理方法をSPMD（Single Program Multiple Data）と呼ぶ事があります。</p><div class="important" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Important</h3><p>SPMD（Single Program Multiple Data）はカーネルがデータと所有するプログラムカウンターに対して複数の処理要素（プロセッシングエレメント、PE）を使い並行で実行されるプログラミングをさします。つまり全ての演算リソースは同一カーネルを実行しますが、自らの命令カウンタを保ちます。さらにカーネル内の分岐により、実際の命令シーケンスは各PEによって大きく異なることがあります。</p></div><p>ワークアイテムはワークグループに分類できます。ワークグループは整数空間を分割して、グローバルIDという単一の整数空間でなく、ワークグループIDとワークグループ内要素を識別するローカルIDの組み合わせによりワークアイテムの座標を表すことができます。</p><p>ワークグループはOpenCLでの並列処理の核心をなす概念です。これは単にグローバル空間を削減するという効果ではなく、プラットフォームモデルでご案内したデバイスの構造をフルに活用するために必須なものです。</p><p>ワークグループ内のワークアイテムは、CU(Compute Unit)内のPE(Processing Element)で並行または並列に実行することができるのです。ただしベンダーが提供するOpenCL実装ライブラリが並行・並列に処理するかは保証されていません。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="n-dim-rangeChapter"></a>NDRange（N-Dimensional Range）</h4></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>NDRangeの詳細・実装例については「<a class="xref" href="ch13s06.html#data-parallel-model" title="データ並列プログラミングモデル">the section called “データ並列プログラミングモデル”</a>」、「<a class="xref" href="ch13s06.html#kernelExecutionChapter" title="カーネルの実行">the section called “カーネルの実行”</a>」、「<a class="xref" href="ch13s18.html" title="13.18. NDRange">Section 13.18, “NDRange”</a>」、「<a class="xref" href="ch13s17.html" title="13.17. ワークグループ">Section 13.17, “ワークグループ”</a>」、「<a class="xref" href="ch17s04.html#workItemChapter" title="17.4.1. ワークアイテム関数">Section 17.4.1, “ワークアイテム関数”</a>」を参照ください。</p></div><p>カーネルインスタンスのインデックス空間は、N次元の範囲（Range）として定義できます。ワークアイテムのグローバルIDとローカルIDは、N-タプルとして表すことができます。Nは1,2,3のいずれかを設定することができます。</p><p>例えばN=1の場合は、`(0)、(1)、(2)、．．．`といったようにインデックスは単なる整数です。</p><p>N=2の場合は、`(0,0)、(0,1)、(0,2)、．．．`というように2次元のインデックスで表せます。</p><p>N=3の場合は、`(0,0,0)、(0,0,1)、(0,0,2)`といったように3次元のインデックスで表せます。</p><p>ワークグループについても、同様にN-タプルで表現できます。例えば2次元のグローバルIDが(3,3)だとするとワークグループの(1,1)のローカルIDは(1,1)となります。この例は後ほど表を使って解説します。</p><p>それでは1次元のカーネルインスタンスの場合の例を見てみましょう。以下の表では、ワークアイテムの総数を8個とし、ワークグループを2つにした場合の、グローバルIDとローカルIDを列挙しています。</p><div class="table"><a id="workgroup1d"></a><p class="title"><strong>Table 13.1. 図：1x8（1次元）カーネル、ワークグループ数=2</strong></p><div class="table-contents"><table class="table" summary="図：1x8（1次元）カーネル、ワークグループ数=2" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /><col class="col_6" /><col class="col_7" /><col class="col_8" /><col class="col_9" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>W</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " colspan="8" align="left" valign="top"><p><span class="emphasis"><em>2</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>G</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " colspan="8" align="left" valign="top"><p><span class="emphasis"><em>8</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>w</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " colspan="4" align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " colspan="4" align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>g</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>2</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>3</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>4</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>5</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>6</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>7</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>l</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>2</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>3</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>2</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>3</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>-</em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(0)</em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(1)</em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(2)</em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(3)</em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(4)</em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(5)</em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(6)</em></span></p></td><td style="" align="left" valign="top"><p><span class="emphasis"><em>(7)</em></span></p></td></tr></tbody></table></div></div><br class="table-break" /><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
W=ワークグループ数
</li><li class="listitem">
G=(グローバル)ワークアイテム数
</li><li class="listitem">
w=ワークグループID
</li><li class="listitem">
g=グローバルID
</li><li class="listitem">
l=ローカルID
</li></ul></div><p>ローカルIDは(0,1,2,3,0,1,2,3)となり各ワークグループの固有なIDが割り振られます。</p><p>次に2次元の例を再度見てみましょう。2次元のインデックス空間を使う場合は大抵は2次元画像の処理をすることを踏まえて、座標を(x,y)の2-タプルで表してみましょう。</p><p>以下は解説で使う変数の定義です。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
(Gx,Gy)：(グローバル)ワークアイテム数
</li><li class="listitem">
(Wx,Wy)：ワークグループ数
</li><li class="listitem">
(Lx,Ly)：ローカルアイテム数
</li><li class="listitem">
(gx,gy)：グローバルID
</li><li class="listitem">
(wx,wy)：ワークグループID
</li><li class="listitem">
(lx,ly)：ローカルID
</li></ul></div><p>ローカルアイテム数については以下のように、ワークアイテム数をワークグループ数で割る事をで算出できます。</p><div class="informalfigure"><div class="mediaobject"><img src="images/workgroup_size_local.png" alt="images/workgroup_size_local.png" /></div></div><p>グローバルIDは、ワークグループIDとローカルアイテム数とローカルIDを合成して算出できます。</p><div class="informalfigure"><div class="mediaobject"><img src="images/workgroup_var_global.png" alt="images/workgroup_var_global.png" /></div></div><p>ワークグループIDと、ローカルIDの計算は以下のような数式を使います。</p><div class="informalfigure"><div class="mediaobject"><img src="images/workgroup_var_all.png" alt="images/workgroup_var_all.png" /></div></div><p>ワークグループIDの計算式は規格に沿ったものですが、少数部分を切り下げる床関数を使って整数に変換する必要があります。</p><p>最後に以下の表が、4x4の2次元インデックス空間の場合の各変数の推移となります。</p><div class="table"><a id="workgroup2d"></a><p class="title"><strong>Table 13.2. 図：4x4（2次元）カーネル、ワークグループ数=2</strong></p><div class="table-contents"><table class="table" summary="図：4x4（2次元）カーネル、ワークグループ数=2" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /><col class="col_5" /><col class="col_6" /><col class="col_7" /><col class="col_8" /><col class="col_9" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>Wy</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>Gy</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>wy</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>gy</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>ly</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " colspan="4" align="left" valign="top"><p><span class="emphasis"><em>(gx, gy)</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " rowspan="4" align="center" valign="middle"><p><span class="emphasis"><em>2</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " rowspan="4" align="center" valign="middle"><p><span class="emphasis"><em>4</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " rowspan="2" align="center" valign="middle"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(0,0)</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(1,0)</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(2,0)</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(3,0)</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(0,1)</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(1,1)</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(2,1)</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(3,1)</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " rowspan="2" align="center" valign="middle"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>2</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(0,2)</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(1,2)</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(2,2)</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(3,2)</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>3</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(0,3)</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(1,3)</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(2,3)</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>(3,3)</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>lx</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>gx</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>2</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>3</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>wx</em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " colspan="2" align="left" valign="top"><p><span class="emphasis"><em>0</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " colspan="2" align="left" valign="top"><p><span class="emphasis"><em>1</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>Gx</em></span></p></td><td style="border-bottom: 1px solid #527bbd; " colspan="4" align="left" valign="top"><p><span class="emphasis"><em>4</em></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em></em></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="emphasis"><em>Wx</em></span></p></td><td style="" colspan="4" align="left" valign="top"><p><span class="emphasis"><em>2</em></span></p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="context-model-chapter"></a>コンテキスト</h4></div></div></div><p>OpenCL実行モデルは、カーネルインスタンスの識別IDやインデックス空間の定義の他にも、OpenCLのホストプログラムのハブとなる（アクセスパタンを指定する）コンテキストを定義します。</p><p>OpenCLアプリケーションでは、コンテキストは以下の４つのリソースを使ってカーネルの実行環境を定義することに用います。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
Devices
</span></dt><dd>
OpenCLデバイスのコレクション
</dd><dt><span class="term">
Kernels
</span></dt><dd>
OpenCLカーネル関数（複数定義可能）
</dd><dt><span class="term">
Programオブジェクト
</span></dt><dd>
カーネルを実装したプログラムソースと実行可能プログラム（カーネルを呼び出すのに用いる動的ライブラリ）
</dd><dt><span class="term">
メモリオブジェクト
</span></dt><dd>
OpenCLデバイスからアクセス可能なメモリ内のオブジェクトの集合
</dd></dl></div><p>DevicesとKernelsについては既に解説してますので、Programオブジェクトとメモリオブジェクトを見てみましょう。</p><p>Programオブジェクトはホストプログラム内でランタイムにビルド（カーネルソースコードのコンパイル）されます。これはOpenCLデバイスのターゲットが分からない状態を前提とすれば、プログラムの実行時にコンパイルして各種デバイスに対して柔軟な運用ができるメリットがあります。</p><p>Programオブジェクトのビルドをするには、ソースが必要ですが、文字列型にしてホストプログラムに置いておくか、外部ファイルをロードしてきます。</p><p>最後にコンテキスト内においてメモリを生成・初期化することができ、生成されたメモリをメモリオブジェクトと呼びます。メモリオブジェクトにはバッファオブジェクトとイメージオブジェクトの２つがあります。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="command-queue-model-chapter"></a>CommandQueue</h4></div></div></div><p>ホストからデバイスへのやり取りは、コマンドキュー(command-queues)というキューに、処理したいコマンドを挿入して行ないます。</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
カーネル実行コマンド
</li><li class="listitem">
メモリー複製・転送コマンド
</li><li class="listitem">
（明示的）同期コマンド
</li></ol></div><p>一つ目のカーネル実行コマンドはOpenCLデバイスのPE上でカーネルを実行させます。</p><p>二つ目は、コマンドキュー(command-queues)を介してデバイスにデータを転送したり、デバイスからデータを受け取る、データをマップ、アンマップするコマンドとなります。データの型式はメモリオブジェクトというOpenCLがサポートするオブジェクトに変換します。</p><p>三つ目の同期コマンドは、コマンドが処理する順序を制御するために使います。</p><p>Contextは複数のコマンドキューと関連付けることができ、各コマンドキューは独立して機能し明示的に同期をさせるメカニズムは存在しません。</p><p>キューは順序通りコマンドを実行するFIFOとできます。反面、out-of-order実行（順不同実行）を行なえるコマンドを挿入することも可能です。順不同実行では、コマンドは順序通り挿入され実行されていきますが、前のコマンドの終了を待機せずに実行をしていきます。</p><p>同一のコマンドキューでは、キューに挿入されたコマンドがイベントオブジェクトを生成することで、コマンド間の同期を行なうことができます。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_メモリーモデル_2"></a>13.6.3. メモリーモデル</h3></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>メモリモデルよりもメモリーモデルの方が呼びやすいのでメモリーモデルと記述します。</p></div><p>Memory ModelはOpenCLで使用するメモリー領域の定義であり、それらがOpenCLの演算との関連を紐付けます。Contextを解説した前の項目で軽くご紹介したメモリオブジェクトはOpenCLで使用するメモリー領域の一つです。</p><p>メモリオブジェクトにはバッファオブジェクト、イメージオブジェクトの２種類
が存在し、メモリオブジェクトは２つのクラスが継承する抽象クラスです。</p><p>原則として、ホストプログラム内のメモリ、つまりホストメモリと、メモリオブジェクトのメモリーモデルは互いに独立したメカニズムや挙動を持ちます。ですが、ホストメモリとメモリオブジェクトは相互作用を持つため、両方の関与を見るべきです。</p><p>バッファオブジェクトやイメージオブジェクト等のメモリオブジェクトは、ホストプログラム内で領域の確保を行います。</p><p>メモリオブジェクトは初期化以外でホストプログラムと関連するのは、メモリオブジェクトの内容を、ホストに複製やマッピング、アンマッピングする場合があります。またデータをホストからメモリオブジェクトに書き込むこともできるため、ホストメモリとメモリオブジェクトの読み込み・書き込みタイミング等は潜在的に問題になりえます。</p><p>メモリへのアクセスのタイミングについては、OpenCLでは２つの方式を選択できるようにしています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Blocking(ブロッキング)
</li><li class="listitem">
Non-Blocking（ノンブロッキング）
</li></ul></div><p>ブロッキング方式では、OpenCL関数はコマンドが処理を終えてリソースが使用可能になった段階で戻ります。ノンブロッキング方式では、コマンドが挿入された時点でOpenCL関数が戻ります。</p><p>OpenCLはメモリ整合性をプロセッサのアーキテクチャに依存してます。下記の図のように４つの種類（＋ホストメモリ）のメモリが混ざりあう構成は、読者が慣れ親しんでいるであろうスタック/ヒープ/コンスタント領域で構成するC言語のメモリーモデルと比べるとやや複雑です。</p><p>OpenCLではメモリには4つの領域があり、それらは各デバイス内のメモリにマップされます。</p><div class="figure"><a id="memory1"></a><p class="title"><strong>Figure 13.2. 図表：メモリー・アーキテクチャー</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/OpenCLMemory.png" alt="images/OpenCLMemory.png" /></div></div></div><br class="figure-break" /><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>この図については後の項目でも引用します。</p></div><p>図にある通りデバイスの中には４つのメモリ空間があります。それにホストメモリ（ホストのメインメモリ）を加えると、５つのメモリ空間が存在します。</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
ホストメモリ
</span></dt><dd>
ホストのみからアクセスが可能となります。OpenCLデバイス内のメモリとの相互作用を除けば、OpenCL特有の制約・機能はありません。
</dd><dt><span class="term">
グローバルメモリ
</span></dt><dd>
全てのワークグループ、ワークアイテムからの読み込み・書き込みアクセスが可能なメモリ領域です。
</dd><dt><span class="term">
コンスタントメモリ
</span></dt><dd>
コンスタント領域は読み込み専用データに使い、グローバルメモリに割り当てます。（注：NVIDIA等の一部のベンダーのデバイスでは個別にキャッシュすることがあります。）書き込み処理を除いてアクセスはグローバルメモリと同じです。
</dd><dt><span class="term">
ローカルメモリ
</span></dt><dd>
一つのワークグループに局所的に割り当てられるメモリー領域です。一つのワークグループ内にある全てのワークアイテムで共有できます。
</dd><dt><span class="term">
プライベートメモリ
</span></dt><dd>
一つのワークアイテムのみが使用できるメモリ領域です。あるワークアイテムにおいてプライベートメモリ領域に変数を宣言した場合、そのメモリ領域には他のワークアイテムからアクセスはできません。
</dd></dl></div><p>ホストメモリを除く４つはカーネル内でアクセスするメモリ領域となります。カーネル内では、原則として緩やかな整合性（異なるワークアイテムで可視化されたメモリーの中身が異なることがある。）を前提とします。では一つ一つのメモリの整合性をみてみましょう。</p><p>まずホストメモリについてはOpenCLが設ける整合性モデルはなく、C言語でいう通常のバッファなので特に言及すべきことはありません。</p><p>プライベートメモリはワークアイテムのみからアクセスが可能となっています。プライベートメモリは順序が保証されているため、ソースコードそのままの順序で処理されます。</p><p>ローカルとグローバルメモリについては、緩やかな整合性を持つため、処理順序は同期点を設けないと確保できません。この同期点はバリアーまたはその他の明示的フェンスを用いて実装できます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_プログラミングモデル"></a>13.6.4. プログラミングモデル</h3></div></div></div><p>Programming ModelはOpenCLでアルゴリズムを実装するための抽象モデルです。プログラミングモデルには以下の２つがあります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
データ並列プログラミングモデル
</li><li class="listitem">
タスク並列プログラミングモデル
</li></ul></div><p>この項目ではこの２つのモデルをOpenCL APIの実装という観点から解説します。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="data-parallel-model"></a>データ並列プログラミングモデル</h4></div></div></div><div class="important" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Important</h3><p>データ並列プログラミングモデルは「図：1x8（1次元）カーネル、ワークグループ数=2」(<a class="xref" href="ch13s06.html#workgroup1d" title="Table 13.1. 図：1x8（1次元）カーネル、ワークグループ数=2">Table 13.1, “図：1x8（1次元）カーネル、ワークグループ数=2”</a>)と「図：4x4（2次元）カーネル、ワークグループ数=2」（<a class="xref" href="ch13s06.html#workgroup2d" title="Table 13.2. 図：4x4（2次元）カーネル、ワークグループ数=2">Table 13.2, “図：4x4（2次元）カーネル、ワークグループ数=2”</a>）で解説したカーネルのグローバルIDの範囲を参照ください。</p></div><p>同一カーネルが並列に処理されるが各カーネルインスタンスは固有の命令カウンタを持つことによって、例えば２次元のイメージ画像のピクセルをx軸、y軸として識別し、各ピクセルに一つのスレッド（ワークアイテム）を割り当てます。</p><p>SPMD（Single Program Multiple Data）はカーネルがデータと所有するプログラムカウンターに対して複数の処理要素（プロセッシングエレメント、PE）を使い並行で実行されるプログラミングをさします。つまり全ての演算リソースは同一カーネルを実行しますが、自らの命令カウンタを保ちます。つまり各カーネルのインスタンス（ワークアイテム）は互いに独立しています。</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>SPMDとカーネルインスタンスの基本動作については「<a class="xref" href="ch13s06.html#kernelExecutionChapter" title="カーネルの実行">the section called “カーネルの実行”</a>」と「<a class="xref" href="ch13s06.html#n-dim-rangeChapter" title="NDRange（N-Dimensional Range）">the section called “NDRange（N-Dimensional Range）”</a>」を参照ください。</p></div><p>データ並列プログラミングモデルを実行するには、処理をさせたいカーネルをキューに挿入する必要があります。それには以下の関数を使います。</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>詳しくは「表：clEnqueueNDRangeKernel」（<a class="xref" href="apbs33.html#clEnqueueNDRangeKernel" title="Table B.88. 表：clEnqueueNDRangeKernel">Table B.88, “表：clEnqueueNDRangeKernel”</a>）を参照ください。</p></div><pre xmlns="" class="prettyprint">pyopencl.enqueue_nd_range_kernel(
    queue, #<a xmlns="http://www.w3.org/1999/xhtml" id="CO7-1"></a>(1)
    kernel, #<a xmlns="http://www.w3.org/1999/xhtml" id="CO7-2"></a>(2)
    global_work_size, #<a xmlns="http://www.w3.org/1999/xhtml" id="CO7-3"></a>(3)
    local_work_size, #<a xmlns="http://www.w3.org/1999/xhtml" id="CO7-4"></a>(4)
    global_work_offset=None, #<a xmlns="http://www.w3.org/1999/xhtml" id="CO7-5"></a>(5)
    wait_for=None, #<a xmlns="http://www.w3.org/1999/xhtml" id="CO7-6"></a>(6)
    g_times_l=False) #<a xmlns="http://www.w3.org/1999/xhtml" id="CO7-7"></a>(7)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-1">(1)</a> </p></td><td valign="top" align="left"><p>
有効なコマンドキューを指定。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-2">(2)</a> </p></td><td valign="top" align="left"><p>
有効なカーネルオブジェクトを指定。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-3">(3)</a> </p></td><td valign="top" align="left"><p>
要素数work_dimの配列で、カーネル関数を実行するwork_dim次元のグローバルワークアイテムの個数を指定。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-4">(4)</a> </p></td><td valign="top" align="left"><p>
要素数work_dimの配列で、カーネル関数を実行する各ワークグループを構成するワークアイテムの数（ワークグループのサイズとも呼ぶ）を指定。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-5">(5)</a> </p></td><td valign="top" align="left"><p>
要素数work_dimの配列でワークアイテムのグローバルIDを決定する際のオフセット値を指定。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-6">(6)</a> </p></td><td valign="top" align="left"><p>
このコマンドが実行される前に完了されているイベントを指定
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO7-7">(7)</a> </p></td><td valign="top" align="left"><p>
global_work_sizeをlocal_work_sizeで乗じた値を使います。
</p></td></tr></table></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>enqueue_nd_range_kernelについては以降の章でコード例を使いながら詳しく解説します。現時点で暗記したり記憶する必要はないので軽く流してください。</p></div><p>キューに挿入後にカーネルは実行されます。カーネルはOpenCL-C言語で定義・記述する関数ですが、C言語との差異はあまりありません。enqueue_nd_range_kernel関数はカーネルとホストプログラムの橋渡しをするだけではなく、データ並列プログラミングモデルをカーネルで実装するための不可欠な関数です。</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="task-parallel-model"></a>タスク並列プログラミングモデル</h4></div></div></div><p>タスク並列プログラミングは、C言語、C++で使うマルチスレッドと基本的には同じ意味を持ちます。</p><p>OpenCLではタスク並列の「タスク」を一つだけのワークアイテムを実行するカーネルと定義しています。</p><p>タスクを実行するには、処理をさせたいカーネルをキューに挿入する必要があります。それには以下の関数を使います。</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>詳しくは「表：clEnqueueTask」（<a class="xref" href="apbs33.html#clEnqueueTask" title="Table B.89. 表：clEnqueueTask">Table B.89, “表：clEnqueueTask”</a>）を参照ください。</p></div><pre xmlns="" class="prettyprint">pyopencl.enqueue_task(
    queue, #<a xmlns="http://www.w3.org/1999/xhtml" id="CO8-1"></a>(1)
    kernel, #<a xmlns="http://www.w3.org/1999/xhtml" id="CO8-2"></a>(2)
    wait_for=None) #<a xmlns="http://www.w3.org/1999/xhtml" id="CO8-3"></a>(3)</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO8-1">(1)</a> </p></td><td valign="top" align="left"><p>
有効なコマンドキューを指定。カーネルはコマンドキューと関連付けられたデバイス上で実行のためにキューに入れられる。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO8-2">(2)</a> </p></td><td valign="top" align="left"><p>
有効なカーネルオブジェクト。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO8-3">(3)</a> </p></td><td valign="top" align="left"><p>
このコマンドが実行される前に完了されているイベントを指定
</p></td></tr></table></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>enqueue_taskについては以降の章で詳しく解説します。現時点で暗記したり記憶する必要はないので軽く流してください。</p></div><p>タスク並列の「並列」については以下のような可能性があります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
タスク内の処理単位をベクトル化して並列化（厳密にはデータ並列プログラミングとの混合）
</li><li class="listitem">
native kernel、つまり外部の並列処理機能を用いる
</li><li class="listitem">
順不同（Out-of-Order）キューへ１個以上のタスクコマンドを挿入
</li></ul></div><p>いずれの方式でタスク並列プログラミングを実行するかは設計上の問題とはなりますが、NDRangeの次元1、ワークアイテム1というシンプルなタスクのプログラミングモデルなので、用途はデータ並列プログラミングモデルと比べると柔軟に選べます。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch13s05.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch13.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch13s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><wrapper xmlns=""><p>Copyright 2018-2019, by Masaki Komatsu</p>


</wrapper></body></html>