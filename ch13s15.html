<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>13.15. Compute UnitとProcessing Element</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Python OpenCL入門" /><link rel="up" href="ch13.html" title="Chapter 13. OpenCLの概要" /><link rel="prev" href="ch13s14.html" title="13.14. Autovectorization" /><link rel="next" href="ch13s16.html" title="13.16. サポートするプロセッサー" /><meta xmlns="" name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch13s14.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch13s16.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_compute_unitとprocessing_element"></a>13.15. Compute UnitとProcessing Element</h2></div></div></div><p>OpenCLをサポートするデバイスには２つの構成物があります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Compute Unit(CU)
</li><li class="listitem">
Processing Element(PE)
</li></ul></div><p>Compute Unitの中にProcessing Elementという処理単位があるので、１つのCUに対して複数のPEが存在することになります。PEは仮想スカラプロセッサであり、デバイスの各パーツにマップされます。</p><p>Compute Unitについては各ベンダーで異なる仕様・形態として定義されています。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Execution Unit（Intel）
</li><li class="listitem">
Streaming MultiProcessor（NVIDIA）
</li><li class="listitem">
Compute Unit（AMD）
</li></ul></div><p>後で追記しますが、PEが処理する単位をOpenCLではワークアイテムと呼びます。１個のワークアイテムは１スレッドに相当します。１個のCUが処理する単位はワークグループと呼びます。</p><p>ワークグループには複数のCUの境界を超えた処理ができない制約があります。例えばCU1とCU2にワークグループ1を割り当てることはできません。反対にワークグループを実際にあるCUの数よりも多く作ることはできます。</p><p>ワークグループとワークアイテムは、CUとPEの概念と類似しているので読者が困惑するかもしれませんが、わかやすく区別する方法があります。ワークグループとワークアイテムは論理的な処理単位でアプリケーションが一時的に生成するもので、CUとPEは物理的に存在するデバイス内の集積回路コンポーネントを抽象化（ないし仮想化）した処理単位と考えることです。</p><p>例えば、ワークグループとワークアイテムは物理的に存在するCUやPEよりも多く割り当てることができます。ワークグループやワークアイテムはソフトウェア上のメモリ領域に存在するもので、コンパイラが各CUやPEにスケジューリング・最適化を行なって、物理層のCUとPEに対してマッピングを行ないます。</p><p>CUとPEは図を見て直感的に把握可能かもしれませんが、OpenCLフレームワークで開発する場合、ワークグループ、ワークアイテムとのマッピングはOpenCL実装ライブラリが行なうため間接的な制御までしかできません。ワークアイテムの定義に追記すると、一つ以上のPE上で実行処理を行なうことができます。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_なぜpeの理解は開発者にとって重要でないのか"></a>13.15.1. なぜPEの理解は開発者にとって重要でないのか？</h3></div></div></div><p>前項の説明ではPEについて全くイメージが湧かないと思います。しかしPEの具体像をもつより、むしろPEの完全な理解は不要と切り捨てるべきと筆者は考えています。</p><p>例えば、NVIDIAのMaxwell-2アーキテクチャでは、Streaming MultiProcessor（SM）と呼ばれるCUには128個のCUDAコアがあり、一般にこれをPEと呼ぶのかもしれません。</p><p>しかしSMにはこの他にLoad/Store Unit（LD）が32個、Special Function Unit（SFU、三角・指数関数の計算等に特化）が32個あります。ワークアイテムとPEのマッピングには、これらも含まなくてはなりません。特定の演算器だけを選んでPEの数とし、その数をワークアイテム数とすると、実際の処理との乖離・誤差が発生します。</p><p>ここで重要な点は、ワークアイテムの数がアラインされているほうが、PEがフル稼働する可能性が高くなることです。このためパフォーマンスをチューニングする際には、できるだけ正確なワークアイテム数が必要となります。しかしOpenCLにはPEの情報を取得するメカニズムが存在しません。</p><p>そのためワークアイテム数の推計を、ベンチマークやプロファイラー等を使って行なう必要があります。このやり方は率直に言えば、いい加減です。ですが開発者にとってPEがいかにマッピングされるかより、チューニングの手間暇が必要な泥臭い部分です。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_execution_unit_intel"></a>13.15.2. Execution Unit(Intel)</h3></div></div></div><p>IntelのHD Graphics GPUでは、CUのことをExecution Unitと呼びます。下記の図を見て頂くと、デバイス内には２つのサブスライスがあり、サブスライス内には複数のEUがあります。</p><div class="figure"><a id="eu"></a><p class="title"><strong>Figure 13.4. 図：Execution Unit</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/executionUnit.png" alt="images/executionUnit.png" /></div></div></div><br class="figure-break" /><p>NVIDIAやAMDの外付けグラフィックボード、IntelのHD Graphics内蔵ボード(iGPU)には、これに対応する処理ユニットが存在します。</p><p>IntelはExecution Unit（EU）がCU、Processing ElementはEU内のSIMDチャンネルに相当するものとしています。</p><p>Intel HD 4000のExecution UnitをCUとしワークグループを割り当てるとすると、少なくとも16個のワークグループを設定したコマンドを作成しないと、EUは待機状態となります。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_streaming_multiprocessor_nvidia"></a>13.15.3. Streaming MultiProcessor(NVIDIA)</h3></div></div></div><p>NVIDIAのCompute UnitはStreaming MultiProcessor（SM）と呼びます。分かりやすくするためにCUDAコアと呼ぶこともあります。下表は幅広く利用されているGTX980とGTX970のスペックです。</p><p>デフォルトのメモリーがGDDR5の4GBですので、IntelのHD Graphicsのグローバルメモリーよりも高速なデータ処理が行なえます。</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>項目</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>GTX 980</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>GTX 970</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>CUDA Cores</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>2048</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>1664</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>Base Clock (MHz)</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>1126</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>1050</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>Boost Clock (MHz)</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>1216</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>1178</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>Texture Fill Rate (GigaTexels/sec)</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>144</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>109</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>Memory Clock</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>7.0 Gbps</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>7.0 Gbps</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>Standard Memory Config</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>4 GB</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>4 GB</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>Memory Interface</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>GDDR5</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>GDDR5</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>Memory Interface Width</strong></span></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>256-bit</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>256-bit</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>Memory Bandwidth (GB/sec)</strong></span></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>224</strong></span></p></td><td style="" align="left" valign="top"><p><span class="strong"><strong>224</strong></span></p></td></tr></tbody></table></div><p>NVIDIAではリリースしたチップセットのアーキテクチャによって、CUに割り当てれる共有メモリーのサイズが異なります。アーキテクチャにはKepler、Maxwell、Pascal（2016年リリース予定）といったものがあります。</p><p>GTX970およびGTX980ではGM204（第２世代Maxwellのコードネーム、第１世代はGM107）アーキテクチャを採用しています。GM204はGraphics Processing Clusters (GPCs)、Streaming Multiprocessors (SMs)、メモリコントローラーからなり、GTX980の構成は以下のようになります。</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
4個のGPC
</li><li class="listitem">
16個のMaxwell SM（SMM）
</li><li class="listitem">
4個のメモリコントローラ
</li></ul></div><p>1個のGPCには4個のSMMとラスターエンジンが付いています。各SMMには128個のCUDAコア（Streaming Processor）が付いています。ちなみにKeplerアーキテクチャでは、SMではなく、SMXと呼ばれていましたが、OpenCLの用語上はCompute Unitと同義です。つまりGTX980は（16*128=）2048個のCUDAコアがあります。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_compute_unit_amd_gcn"></a>13.15.4. Compute Unit(AMD GCN)</h3></div></div></div><p>AMDはGCN（Graphics Core Next）規格をGPUデバイスに採用しています。GCNではGCN Compute Unitと、OpenCLと同名を使います。</p><p>GCNは旧世代アーキテクチャのVLIW (Very Long Instruction Word) に代わり、４つの独立したSIMDを持ちます。SIMDエンジンはグループ分けした64個のワークアイテム（スレッド）を発行することができ、このグループをwavefrontと呼びます。</p><p>各SIMDは、16個のワークアイテムを並列に処理できます。各ワークアイテムは別のwavefrontでも処理が可能となり、柔軟なSIMDチャンネルのスケジューリングを可能とさせます。</p><div class="table"><a id="idm3425"></a><p class="title"><strong>Table 13.14. GCNとVLIW4の比較</strong></p><div class="table-contents"><table class="table" summary="GCNとVLIW4の比較" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> VLIW4 SIMD</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> GCN QUAD SIMD</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>64 単精度 Mad(Multiply and Add)</strong></span></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>64 単精度 Mad(Multiply and Add)</strong></span></p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><span class="strong"><strong>1 VLIW x 4 ALU ops</strong></span></p></td><td style="" align="left" valign="top"><p><span class="strong"><strong>4 SIMD x 1 ALU ops</strong></span></p></td></tr></tbody></table></div></div><br class="table-break" /><p>各SIMDは40-bitのプログラムカウンターと、10個のwavefrontで用いる命令バッファーを持ちます。つまり、各CUは4つのSIMD、つまり40個のwavefrontを異なるワークグループやカーネルから活用できます。32 x CUをもつAMD Radeon HD 7970であれば、最大81,920のワークアイテムを同時に処理が可能となります。</p><p>HBMを搭載して省電力化を実現したFury X等のGPUもGCNアーキテクチャを採用しており、OpenCLで開発を行なう場合には、OpenCLのバージョンを除いては特に変わることはありません。</p><p>GCNには1.0/1.1/1.2のバージョンがあります。もし詳細の仕様を知りたい場合は、お使いのAMD GPUがどのバージョンをサポートしている確認してから、「GCN Architecture Whitepaper」等のドキュメントを参照するとよいでしょう。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch13s14.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch13.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch13s16.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><wrapper xmlns=""><p>Copyright 2018-2019, by Masaki Komatsu</p>


</wrapper></body></html>