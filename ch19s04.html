<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>19.4. 高速フーリエ変換（Fast Fourier Transform）</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Python OpenCL入門" /><link rel="up" href="ch19.html" title="Chapter 19. 高速フーリエ変換（Fast Fourier Transform）" /><link rel="prev" href="ch19s03.html" title="19.3. 離散フーリエ変換（Discrete Fourier Transform）" /><link rel="next" href="ch19s05.html" title="19.5. 実装例（CPU）" /><meta xmlns="" name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch19s03.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch19s05.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_高速フーリエ変換_fast_fourier_transform_2"></a>19.4. 高速フーリエ変換（Fast Fourier Transform）</h2></div></div></div><p>高速フーリエ変換は離散フーリエ変換の計算量を削減するアルゴリズムです。FFTの導出には、以下のように指数関数の部分を <span class="inlinemediaobject"><img src="images/lomega.png" alt="images/lomega.png" /></span> として簡略表記します。</p><div class="informalfigure"><div class="mediaobject"><img src="images/discrete_fourier.png" alt="images/discrete_fourier.png" /></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>この指数関数を行列として表記する場合は <span class="inlinemediaobject"><img src="images/Omega.png" alt="images/Omega.png" /></span> として記述します。</p></div><p>離散フーリエ変換で検証したN=4のケースを行列にすると以下の行列に指数関数部分をまとめることができます。</p><div class="informalfigure"><div class="mediaobject"><img src="images/Omega_4.png" alt="images/Omega_4.png" /></div></div><p>同様にN=8の場合は以下のように表せます。</p><div class="informalfigure"><div class="mediaobject"><img src="images/Omega_8.png" alt="images/Omega_8.png" /></div></div><p>このN=4、N=8からFFTの基本アルゴリズムの導出が可能となります。まずN=8の<span class="inlinemediaobject"><img src="images/Omega.png" alt="images/Omega.png" /></span>のパターンと、N=4の<span class="inlinemediaobject"><img src="images/Omega.png" alt="images/Omega.png" /></span>が類似している部分を探します。</p><p>類似点は、<span class="inlinemediaobject"><img src="images/f_0.png" alt="images/f_0.png" /></span>, <span class="inlinemediaobject"><img src="images/f_1.png" alt="images/f_1.png" /></span>, <span class="inlinemediaobject"><img src="images/f_2.png" alt="images/f_2.png" /></span>, <span class="inlinemediaobject"><img src="images/f_3.png" alt="images/f_3.png" /></span>, <span class="inlinemediaobject"><img src="images/f_4.png" alt="images/f_4.png" /></span>, <span class="inlinemediaobject"><img src="images/f_5.png" alt="images/f_5.png" /></span>, <span class="inlinemediaobject"><img src="images/f_6.png" alt="images/f_6.png" /></span>, <span class="inlinemediaobject"><img src="images/f_7.png" alt="images/f_7.png" /></span>の並びを、<span class="inlinemediaobject"><img src="images/f_0.png" alt="images/f_0.png" /></span>, <span class="inlinemediaobject"><img src="images/f_2.png" alt="images/f_2.png" /></span>, <span class="inlinemediaobject"><img src="images/f_4.png" alt="images/f_4.png" /></span>, <span class="inlinemediaobject"><img src="images/f_6.png" alt="images/f_6.png" /></span>, <span class="inlinemediaobject"><img src="images/f_1.png" alt="images/f_1.png" /></span>, <span class="inlinemediaobject"><img src="images/f_3.png" alt="images/f_3.png" /></span>, <span class="inlinemediaobject"><img src="images/f_5.png" alt="images/f_5.png" /></span>, <span class="inlinemediaobject"><img src="images/f_7.png" alt="images/f_7.png" /></span>に入れ替えると明らかになります。</p><p>並び替え後の行列は以下のように変わります。</p><div class="informalfigure"><div class="mediaobject"><img src="images/Omega_F_8.png" alt="images/Omega_F_8.png" /></div></div><p>この式を入念に観察すると<span class="inlinemediaobject"><img src="images/Omega.png" alt="images/Omega.png" /></span>行列の左上部分が4x4の行列を構成し、N=4のケースと合致します。同様に左下の4x4の部分は、N=4の<span class="inlinemediaobject"><img src="images/Omega.png" alt="images/Omega.png" /></span>を構成します。</p><div class="informalfigure"><div class="mediaobject"><img src="images/Omega_F_8_final.png" alt="images/Omega_F_8_final.png" /></div></div><p>Dは<span class="inlinemediaobject"><img src="images/Omega.png" alt="images/Omega.png" /></span>と対角行列ですが、N＝4の<span class="inlinemediaobject"><img src="images/Omega.png" alt="images/Omega.png" /></span>と乗じることで、右上の4x4行列、右下の4x4行列を再現できます。</p><div class="informalfigure"><div class="mediaobject"><img src="images/Diag_omega.png" alt="images/Diag_omega.png" /></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_cooley_tukey型アルゴリズム"></a>19.4.1. Cooley-Tukey型アルゴリズム</h3></div></div></div><p>Cooley–Tukey型アルゴリズムは、派生アルゴリズムが多数あります。その中で最も使用頻度が高いとされるのが、Radix-2 FFTです。</p><p>Radix-2 FFTの導出は以下の式で表すことができます。</p><div class="informalfigure"><div class="mediaobject"><img src="images/radix-2-derivation.png" alt="images/radix-2-derivation.png" /></div></div><p>(1)　DFT（離散フーリエ変換）の式を、偶数（Even）と奇数（Odd）の2つに分割します。</p><p>(2)　奇数の項をさらに分割して、指数関数部分（<span class="inlinemediaobject"><img src="images/Omega.png" alt="images/Omega.png" /></span>）を取り出します。</p><p>(3)　偶数項の周期がN/2であることを示します。</p><p>(4)　奇数項の周期がN/2であることを示します。</p><p>(5)　N/2を境にしてFの値が変動することを示します。</p><p>(6)　(5)の上辺からFの導出となります。</p><p>(7)　(3)、(4)と(5)の下辺から、t+N/2のFの導出となります。</p><p>上記の結果を一般化して、アルゴリズムとして表すと以下の擬似コードに一般化することができます。</p><div class="informalfigure"><div class="mediaobject"><img src="FFT1D.png" alt="FFT1D.png" /></div></div><p>Cooley-Tukey型アルゴリズムは、nの2乗からO(n log2 n)に計算量を削減することが可能です。</p><p>CPUを使用した古典的アルゴリズムは再帰的に処理を行いますが、以下のようなパラメーターと戻り値を持ちます。</p><div class="informalexample"><div class="variablelist"><dl class="variablelist"><dt><span class="term">
f
</span></dt><dd>
観測点：<span class="inlinemediaobject"><img src="images/f_0.png" alt="images/f_0.png" /></span>, <span class="inlinemediaobject"><img src="images/f_1.png" alt="images/f_1.png" /></span>, <span class="inlinemediaobject"><img src="images/f_2.png" alt="images/f_2.png" /></span>, … , <span class="inlinemediaobject"><img src="images/f_N-1.png" alt="images/f_N-1.png" /></span>
</dd><dt><span class="term">
N
</span></dt><dd>
データの個数（観測点の数）、各ステージで処理するデータ数
</dd><dt><span class="term">
offset
</span></dt><dd>
オフセット、再帰時に処理を開始する位置
</dd><dt><span class="term">
F
</span></dt><dd>
変換後の周波数信号
</dd></dl></div></div><p>offsetは再帰時の各位置となります。例えば以下のように再帰処理で高速フーリエ変換を行う関数の各ステップ（又はステージ）の処理を一般化してみましょう。</p><div class="orderedlist"><p class="title"><strong>FFT(f, N, offset)</strong></p><ol class="orderedlist" type="1"><li class="listitem">
部分列を入力（f: <span class="inlinemediaobject"><img src="images/f_0.png" alt="images/f_0.png" /></span>, <span class="inlinemediaobject"><img src="images/f_1.png" alt="images/f_1.png" /></span>, <span class="inlinemediaobject"><img src="images/f_2.png" alt="images/f_2.png" /></span>, … , <span class="inlinemediaobject"><img src="images/f_N-1.png" alt="images/f_N-1.png" /></span>）
</li><li class="listitem">
FFT(f,N/2,offset) → <span class="inlinemediaobject"><img src="images/F0.png" alt="images/F0.png" /></span>, <span class="inlinemediaobject"><img src="images/F1.png" alt="images/F1.png" /></span>, … , <span class="inlinemediaobject"><img src="images/F_N2-1.png" alt="images/F_N2-1.png" /></span>
</li><li class="listitem">
FFT(f,N/2,offset+N/2) → <span class="inlinemediaobject"><img src="images/F_N2.png" alt="images/F_N2.png" /></span>, … , <span class="inlinemediaobject"><img src="images/FN-1.png" alt="images/FN-1.png" /></span>
</li></ol></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Nが1の場合は<span class="inlinemediaobject"><img src="images/F0.png" alt="images/F0.png" /></span> = <span class="inlinemediaobject"><img src="images/f_0.png" alt="images/f_0.png" /></span>とします。初回は入力にfの全配列、以降の再帰ツリーの走査は、アルゴリズムの各ステップ（ステージ）では前に出力したFを入力値として使います。</p></div><p>(2)と(3)で、部分列を1/2に分割していき、最終的には、N＝2まで再帰するものとします。</p><p>この一連の再帰処理については「図：FFT整列ネットワーク（N=8）」（<a class="xref" href="ch19s04.html#fft-sorting-network-8" title="Figure 19.1. 図：FFT整列ネットワーク（N=8）">Figure 19.1, “図：FFT整列ネットワーク（N=8）”</a>）を参照ください。</p><div class="figure"><a id="fft-sorting-network-8"></a><p class="title"><strong>Figure 19.1. 図：FFT整列ネットワーク（N=8）</strong></p><div class="figure-contents"><div class="mediaobject"><img src="FFT-sorting-network-8.png" alt="FFT-sorting-network-8.png" /></div></div></div><br class="figure-break" /><p>図では、stage0はN=2、stage1はN=4、stage2はN=8の周波数成分というように前のステージで計算した結果を、次のステージでは倍の規模のFFTの入力に使うことができます。CPU処理で一般的な再帰を使う場合は、stage2→stage1→stage0という順序で呼び出しますが、実際の「処理順序」はstage0→stage1→stage2となります。</p><p>stage0の入力は観測値[<span class="inlinemediaobject"><img src="images/f_0.png" alt="images/f_0.png" /></span>,<span class="inlinemediaobject"><img src="images/f_1.png" alt="images/f_1.png" /></span>,…,<span class="inlinemediaobject"><img src="images/f_N-1.png" alt="images/f_N-1.png" /></span>]としますが、図のように上半分に偶数の添字、下半分に奇数の添字となるよう再配置します。</p><p>この再配置は奇数と偶数をスワップするだけですが、ビット反転を使うことで、容易に実装することができます。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_bit_reversal"></a>19.4.2. Bit Reversal</h3></div></div></div><p>ビット反転（bit reversal）は、Cooley-Tukey型アルゴリズムにおける偶数項と、奇数項の分離のために使うことができます。</p><p>例えば整数の「3」のビット反転をする場合は3を2進数にまず変換します。</p><pre xmlns="" class="prettyprint">00000000000000000000000000000011</pre><p>これをビット反転すると以下のような2進数の列に変換されます。</p><pre xmlns="" class="prettyprint">11000000000000000000000000000000</pre><p>ビットの反転は、このように対応する位置にあるビットをスワップ（入れ替え）します。「3」の例で言えば、1桁目と32桁目のビットを交換したことになります。</p><p>ではビット反転の実装を考えてみます。</p><pre xmlns="" class="prettyprint">def reverse_bit(x, stage):
    b = 0
    bits = stage
    while bits != 0: #<a xmlns="http://www.w3.org/1999/xhtml" id="CO70-1"></a>(1)
        b &lt;&lt;= 1 #<a xmlns="http://www.w3.org/1999/xhtml" id="CO70-2"></a>(2)
        b |= (x &amp; 1) #<a xmlns="http://www.w3.org/1999/xhtml" id="CO70-3"></a>(3)
        x &gt;&gt;= 1 #<a xmlns="http://www.w3.org/1999/xhtml" id="CO70-4"></a>(4)
        bits &gt;&gt;= 1 #<a xmlns="http://www.w3.org/1999/xhtml" id="CO70-5"></a>(5)
    return b</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#CO70-1">(1)</a> </p></td><td valign="top" align="left"><p>
bits変数が0になるまで繰り返します。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO70-2">(2)</a> </p></td><td valign="top" align="left"><p>
b変数を左に一桁分シフトします。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO70-3">(3)</a> </p></td><td valign="top" align="left"><p>
引数xの1桁目の値をb変数にコピーします。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO70-4">(4)</a> </p></td><td valign="top" align="left"><p>
引数xを左シフトします。
</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#CO70-5">(5)</a> </p></td><td valign="top" align="left"><p>
bitsを右シフトします。
</p></td></tr></table></div><p>シフト演算子は2進数の1/0のビットの読み込む順番を制御するために使います。引数xは右シフトすることにより、右側のビットから読み込み、変数xの右側にコピーしたビットは、左にシフトすることで、ビットを反転していきます。</p><p>最後に配列をビット反転した添字に基づいて並び変えてみます。</p><pre xmlns="" class="prettyprint">for i in range(2, size*2, 2):
    rev = reverse_bit(np.uint32(i/2), size-1) * 2
    if i &lt; rev:
        print("i: " + str(i / 2)+" rev:" + str(rev / 2))
        tmpR = data[i]
        tmpI = data[i+1]
        data[i] = data[rev]
        data[i+1] = data[rev+1]
        data[rev] = tmpR
        data[rev+1] = tmpI</pre><p>data配列を並び変える際には、複素数の処理が入ります。添字iとrevを入れ替えるだけでなく、虚数部分の入れ替えも同時に行います。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch19s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch19.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch19s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><wrapper xmlns=""><p>Copyright 2018-2019, by Masaki Komatsu</p>


</wrapper></body></html>