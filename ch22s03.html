<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>22.3. Reduction（還元）</title><link rel="stylesheet" type="text/css" href="index.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Python OpenCL入門" /><link rel="up" href="ch22.html" title="Chapter 22. 基数配列" /><link rel="prev" href="ch22s02.html" title="22.2. Bucket Scan" /><link rel="next" href="ch22s04.html" title="22.4. Prefix Sumへの適用" /><meta xmlns="" name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0" /><script xmlns="" type="text/javascript" src="prettify/prettify.js"></script><link xmlns="" rel="stylesheet" type="text/css" href="prettify/skins/sons-of-obsidian.css" /><script xmlns="">
    window.addEventListener("load", function() {
      PR.prettyPrint();
	  });	
	</script><script xmlns="" type="text/javascript" src="script/head.js"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch22s02.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch22s04.html">Next</a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_reduction_還元"></a>22.3. Reduction（還元）</h2></div></div></div><div class="warning" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Warning</h3><p>Reductionは一般的な数学や情報工学の用語です。この項目ではPrefix-Sumsの計算アルゴリズムの効率化をするための一手法とお考え下さい。時間を節約したい方はとばしていただいて構いません。</p></div><p>Reduction（還元）の基本的な考え方は数学的抽象性と一般性を持つため、解説の際には本来直感的に理解できるものを無駄に難しい数式を使って記述する傾向があるように思います。</p><p>無論、本書のターゲット読者は実務的にコードを設計する技術者のため、直感的なアプローチを取らせていただきます。</p><p>まずReductionについては筆者は一例を紹介しています。前の項目で解説した「表：Prefix-Sumの要素分解図」（<a class="xref" href="ch22s02.html#prefix-sum" title="Table 22.3. 表：Prefix-Sumの要素分解図（括弧内の数は式番号に該当）">Table 22.3, “表：Prefix-Sumの要素分解図（括弧内の数は式番号に該当）”</a>）は、Reduction法に該当します。</p><p>Prefix-Sum（<a class="xref" href="ch22s02.html#prefix-sum-example" title="Table 22.2. 表：Prefix Sumの一例">Table 22.2, “表：Prefix Sumの一例”</a>）は配列の和を求めて上昇配列を構成しますが、Reduction法は配列の和を分解して、計算アルゴリズムのデータ並列化をします。</p><p>前の項目で解説したシーケンシャルなPrefix-Sumのアルゴリズムは、「図：シーケンシャルな還元」（<a class="xref" href="ch22s03.html#reduction-simple-accumulator" title="Figure 22.2. 図：シーケンシャルな還元">Figure 22.2, “図：シーケンシャルな還元”</a>）のように配列の左要素から部分和（掃き上げ）をしていきます。</p><div class="figure"><a id="reduction-simple-accumulator"></a><p class="title"><strong>Figure 22.2. 図：シーケンシャルな還元</strong></p><div class="figure-contents"><div class="mediaobject"><img src="reduction-simple-accumulator.png" width="400" alt="reduction-simple-accumulator.png" /></div></div></div><br class="figure-break" /><p>シーケンシャルな還元は再帰（Recursion）として実装ができますが、パフォーマンスはデータサイズが増えるほど急激に劣化します。</p><p>次にGPGPUを使った還元アルゴリズムの例ですが、「表：Prefix-Sumの要素分解図」（<a class="xref" href="ch22s02.html#prefix-sum" title="Table 22.3. 表：Prefix-Sumの要素分解図（括弧内の数は式番号に該当）">Table 22.3, “表：Prefix-Sumの要素分解図（括弧内の数は式番号に該当）”</a>）を一般化すると、「図：並列化した還元」（<a class="xref" href="ch22s03.html#reduction-parallel-accumulator" title="Figure 22.3. 図：並列化した還元">Figure 22.3, “図：並列化した還元”</a>）というような図式で表すことができます。</p><p>この方式はデータ並列化のための処方箋として加算演算の「結合性」（associativity）を利用しています。</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_結合性"></a>22.3.1. 結合性</h3></div></div></div><p>結合性とは（1,2,3）の総和を計算する際にシーケンシャルな計算では(1+2)+3とするのに対して、1+(2+3)といったように部分和の再グループ化を可能とします。</p><p>つまり部分和を分解・再グループ化します。グループ化によって並列化できる要素を増やすことができます。ステップが進むと逆三角形、逆ピラミッドのようになるため、並列性は落ちますが、リソースをもっとも使うベースの部分和については、並列コアが飽和している状況が想定されるため、アルゴリズムの終結部のステップにいたるまでは、高い並列性を保つことができます。</p><div class="figure"><a id="reduction-parallel-accumulator"></a><p class="title"><strong>Figure 22.3. 図：並列化した還元</strong></p><div class="figure-contents"><div class="mediaobject"><img src="reduction-parallel-accumulator.png" width="400" alt="reduction-parallel-accumulator.png" /></div></div></div><br class="figure-break" /><p>この並列化を行うとSIMD使用率は「図：並列化した還元のSIMD使用パターン」（<a class="xref" href="ch22s03.html#reduction-assoc-simd" title="Figure 22.4. 図：並列化した還元のSIMD使用パターン">Figure 22.4, “図：並列化した還元のSIMD使用パターン”</a>）のようになります。使用するレジスタが分散しており最適化の余地があります。つまり飛び地ができることで、SIMDのレジスタの未使用部分が増加し、大量のスレッドで並列コアを飽和させても、物理的リソースの多くが使用されない状況となります。</p><div class="figure"><a id="reduction-assoc-simd"></a><p class="title"><strong>Figure 22.4. 図：並列化した還元のSIMD使用パターン</strong></p><div class="figure-contents"><div class="mediaobject"><img src="reduction-assoc-simd.png" width="400" alt="reduction-assoc-simd.png" /></div></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_交換性"></a>22.3.2. 交換性</h3></div></div></div><p>SIMDの使用率を改善するためのアルゴリズムも存在し、広く活用されています。飛び地を作らないためには、加算演算の「交換性」（commutativity）を利用して、加算する要素の添字をリファクタリングします。</p><p>交換性とは、(1,2,3,4)の総和を計算するときに、(1+4)+(2+3)=(5+5)=10といったように計算する順序を都合の良いように変えても、結果に影響を与えません。</p><div class="figure"><a id="idm10459"></a><p class="title"><strong>Figure 22.5. 図：交換性を利用した還元アルゴリズム</strong></p><div class="figure-contents"><div class="mediaobject"><img src="reduction-commutative.png" width="400" alt="reduction-commutative.png" /></div></div></div><br class="figure-break" /><p>この方式を使うと、並列コアのレジスタの飛び地を減らし、SIMDの使用率を大幅に上げることができます。</p><div class="figure"><a id="idm10467"></a><p class="title"><strong>Figure 22.6. 図：交換性を利用したアルゴリズムのSIMD使用パターン</strong></p><div class="figure-contents"><div class="mediaobject"><img src="reduction-commutative-simd.png" width="400" alt="reduction-commutative-simd.png" /></div></div></div><br class="figure-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch22s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch22.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch22s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div><wrapper xmlns=""><p>Copyright 2018-2019, by Masaki Komatsu</p>


</wrapper></body></html>